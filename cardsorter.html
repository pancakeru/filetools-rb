<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>å¡ç‰Œåˆ†ç±»å™¨</title>
  <style>
    body {
      font-family: sans-serif;
      padding: 30px;
      max-width: 800px;
      margin: auto;
      background-image: url("images/pinkkU.jpg");
      background-repeat: repeat;
    }

    h2 {
      margin-bottom: 10px;
    }

    label {
      display: block;
      margin-top: 12px;
    }

    input[type="number"] {
      width: 80px;
    }

    .section {
      border: 1px solid #ccc;
      padding: 10px;
      margin-bottom: 20px;
      border-radius: 8px;
      background-color: white;
    }

    .row {
      display: flex;
      gap: 20px;
      align-items: center;
      margin-top: 8px;
    }

    button {
      padding: 10px 20px;
      font-size: 16px;
      margin-top: 20px;
      cursor: pointer;
    }

    .tag {
      display: inline-block;
      background: #eee;
      padding: 5px 10px;
      border-radius: 6px;
      margin-right: 10px;
    }

    #resultTable {
    transition: all 0.3s ease;
    }

    #toggleTableBtn {
        display: none;
        margin-top: 20px;
        margin-left: 41%;
        font-size: 14px;
        padding: 6px 12px;
        border-radius: 6px;
        background-color: #f0f0f0;
        border: 1px solid #ccc;
        cursor: pointer;
    }

    #contentContainer {
      background-color: rgb(255, 255, 255, 0.8);
      margin-top: 0%;
      margin-bottom: 0%;
      padding: 2%;
      border-radius: 1%;
    }

  </style>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
</head>
<body>
<div id="contentContainer">
  <h1 style="margin-left: 30%;">ğŸƒ å¡ç‰Œåˆ†ç±»å’Œæ‰“åŒ…å™¨</h1>

  <div class="section" id="folderDropZone">
  <h2>æ‹–æ”¾å¡ç‰Œæ–‡ä»¶å¤¹</h2>
  <div id="folderDropArea" style="
    border: 2px dashed #aaa;
    border-radius: 10px;
    padding: 40px;
    text-align: center;
    color: #555;
    cursor: pointer;
    transition: border-color 0.3s ease;
  ">
    ğŸ“‚ æ‹–æ”¾åŒ…å« PNG å›¾ç‰‡çš„æ–‡ä»¶å¤¹åˆ°æ­¤åŒºåŸŸ
    <br><br>
    ï¼ˆæˆ–ç‚¹å‡»æ­¤å¤„æ‰‹åŠ¨é€‰æ‹©æ–‡ä»¶å¤¹ï¼‰
  </div>
  <input type="file" id="folderInput" webkitdirectory directory multiple style="display: none;">
  <button id="clearBtn" style="margin-top: 10px; margin-left: 40%; font-size: 14px;
        padding: 6px 12px;
        border-radius: 6px;
        background-color: #f0f0f0;
        border: 1px solid #ccc;
        cursor: pointer;">ğŸ—‘ æ¸…é™¤ä¸Šä¼ æ–‡ä»¶</button>
</div>

<div id="folderFilterContainer" style="margin-top: 20px; display: flex; flex-direction: column; align-items: center;"></div>

<p style="font-size: small; text-align: center; align-self: center;">æ²¡æœ‰ç¬¦åˆä»»ä½•ç­›é€‰æ¡ä»¶çš„æ–‡ä»¶ä¼šè¢«è‡ªåŠ¨æ”¾å…¥ä¸€ä¸ªå•ç‹¬çš„æ–‡ä»¶å¤¹ä¸­ã€‚</p>

<button
  id="addFolderBtn"
  style="
    display: inline-block;
    margin-top: 10px;
    padding: 6px 12px;
    font-size: 13px;
    width: 400px;
    border-radius: 6px;
    background-color: #e0e0e0;
    border: 1px solid #ccc;
    cursor: pointer;
"
onclick="NewFolder()"
>
â• æ–°å¢ç­›é€‰æ–‡ä»¶å¤¹
</button>

  <button onclick="applyAllFilters()" style="margin-left: 45%; margin-bottom: 2%;">æäº¤</button>

  <div class="section">
    <h2>é¢„è§ˆ</h2>
    <div id="previewBox">
        <div id="resultSummary"></div>
       
       <div id="zipSection" style="margin-top: 20px; display: flex; flex-wrap: wrap; justify-content: center; gap: 30px;"></div>
        <button id="toggleTableBtn" style="display: none;" onclick="tableControl()">â¬‡ï¸ æŸ¥çœ‹è¯¦ç»†ç»“æœ</button>
       
        <div style="text-align: center; margin-top: 30px;">
        <button onclick="downloadAllFoldersZip()" style="padding: 8px 16px; font-size: 14px;">
            ğŸ“¦ ä¸‹è½½æ‰€æœ‰æ–‡ä»¶å¤¹ï¼ˆæ•´åˆæ‰“åŒ…ï¼‰
        </button>
        </div>

        <div id="resultsPreview" style="margin-top: 30px;">
          <div style="text-align: center; margin-bottom: 10px;">
           <button onclick="prevResultPage()" id="prevPageBtn" disabled 
           style="font-size: 14px;
        padding: 6px 12px;
        border-radius: 6px;
        background-color: #f0f0f0;
        border: 1px solid #ccc;
        cursor: pointer;">â¬…ï¸ ä¸Šä¸€é¡µ</button>
            <button onclick="nextResultPage()" id="nextPageBtn" style="font-size: 14px;
        padding: 6px 12px;
        border-radius: 6px;
        background-color: #f0f0f0;
        border: 1px solid #ccc;
        cursor: pointer;" disabled>ä¸‹ä¸€é¡µ â¡ï¸</button>
        </div>

  <div id="resultTableContainer"></div>
</div>
        <div id="resultTable" style="display: none; margin-top: 10px;"></div>
    </div>
</div>

  </div>


<!--JAVASCRIPT STARTS HERE-->
  <script>
let folderCount = 0;
let currentPage = 0;
const foldersPerPage = 2;

function downloadZip(fileArray, zipName) {
  if (!fileArray || fileArray.length === 0) {
    alert("æ²¡æœ‰æ–‡ä»¶å¯ä¸‹è½½ï¼");
    return;
  }

  const zip = new JSZip();

  const sortedFiles = fileArray.slice().sort((a, b) => {
    return a.name.localeCompare(b.name, 'zh-Hans', { numeric: true, sensitivity: 'base' });
  });

  sortedFiles.forEach(file => {
    zip.file(file.name, file);
  });

  zip.generateAsync({ type: "blob" }).then(content => {
    saveAs(content, zipName);
  });
}

//fetch folder path
 const folderDropArea = document.getElementById("folderDropArea");
const folderInput = document.getElementById("folderInput");

let droppedFiles = [];
let folderStats = []; 

let filteredFiles = [];
let excludedFiles = [];

let isTableVisible = false;
let folderResults = []; // store per-folder results

let importedNames = [];

folderDropArea.addEventListener("click", () => {
  folderInput.click(); // trigger manual folder select
});

window.addEventListener("DOMContentLoaded", () => {
    NewFolder();
  });

folderInput.addEventListener("change", (e) => {
  const files = Array.from(e.target.files).filter(file => file.name.toLowerCase().endsWith(".png"));
  handleFolderDrop(files);
  folderInput.value = ""; // reset so same folder can be reselected
});

function updateDropDisplay() {
  const total = droppedFiles.length;
  let html = `<div style="text-align: center;">ğŸ“ å·²åŠ è½½ ${total} å¼ å›¾ç‰‡`;

  if (folderStats.length > 0) {
    html += `<br><br>æ¥è‡ªä»¥ä¸‹æ–‡ä»¶å¤¹ï¼š<br>`;
    folderStats.forEach(f => {
      html += `${f.folderName}ï¼š${f.count} å¼ <br>`;
    });
  }

  html += `</div>`;
  folderDropArea.innerHTML = html;

  console.log("ğŸ“¦ å½“å‰ PNG æ–‡ä»¶æ€»æ•°ï¼š", total);
}


function downloadAllFoldersZip() {
  if (!folderResults || folderResults.length === 0) {
    alert("æ²¡æœ‰ä»»ä½•ç­›é€‰ç»“æœï¼");
    return;
  }

  const masterZip = new JSZip();

  folderResults.forEach((result, index) => {
    const folderName = result.customName || `ç­›é€‰æ–‡ä»¶å¤¹ ${result.folderNumber}`;
    const sortedFiles = result.files.slice().sort((a, b) =>
      a.name.localeCompare(b.name, 'zh-Hans', { numeric: true, sensitivity: 'base' })
    );

    sortedFiles.forEach(file => {
      masterZip.folder(folderName).file(file.name, file);
    });
  });

  masterZip.generateAsync({ type: "blob" }).then(content => {
    saveAs(content, "æ‰€æœ‰ç­›é€‰ç»“æœ.zip");
  });
}


document.getElementById("clearBtn").addEventListener("click", () => {
  droppedFiles = [];
  folderStats = [];
  folderDropArea.innerHTML = `ğŸ“‚ æ‹–æ”¾åŒ…å« PNG å›¾ç‰‡çš„æ–‡ä»¶å¤¹åˆ°æ­¤åŒºåŸŸ<br><br>ï¼ˆæˆ–ç‚¹å‡»æ­¤å¤„æ‰‹åŠ¨é€‰æ‹©æ–‡ä»¶å¤¹ï¼‰`;
  console.log("ğŸ—‘ å·²æ¸…é™¤æ‰€æœ‰ä¸Šä¼ æ–‡ä»¶");
});

folderDropArea.addEventListener("dragover", (e) => {
  e.preventDefault();
  folderDropArea.style.borderColor = "#666";
});
folderDropArea.addEventListener("dragleave", () => {
  folderDropArea.style.borderColor = "#aaa";
});
folderDropArea.addEventListener("drop", (e) => {
  e.preventDefault();
  folderDropArea.style.borderColor = "#aaa";
  const items = [...e.dataTransfer.items];
  const allFiles = [];

  for (let item of items) {
    const entry = item.webkitGetAsEntry?.();
    if (entry && entry.isDirectory) {
      readAllFromDirectory(entry, allFiles).then(() => {
        handleFolderDrop(allFiles);
      });
      return;
    } else {
      const file = item.getAsFile();
      if (file) allFiles.push(file);
    }
  }


  // fallback if no directory
  handleFolderDrop(allFiles);
});

function handleFolderDrop(fileList) {
    console.log("âœ… Folder selected! Files:", fileList.length);

  const newFiles = Array.from(fileList).filter(file => file.name.toLowerCase().endsWith(".png"));

  const existingPaths = new Set(droppedFiles.map(f => f.webkitRelativePath || f.name));

  // Track how many new files are from each folder
  const localFolderCounts = {};

  newFiles.forEach(file => {
    const path = file.webkitRelativePath || file.name;
    if (!existingPaths.has(path)) {
      droppedFiles.push(file);

      // Get folder name
      const folder = path.includes("/") ? path.split("/")[0] : "(æœªçŸ¥æ–‡ä»¶å¤¹)";
      localFolderCounts[folder] = (localFolderCounts[folder] || 0) + 1;
    }
  });

  // Merge folder counts into folderStats
  for (const folder in localFolderCounts) {
    const existing = folderStats.find(f => f.folderName === folder);
    if (existing) {
      existing.count += localFolderCounts[folder];
    } else {
      folderStats.push({ folderName: folder, count: localFolderCounts[folder] });
    }
  }

  updateDropDisplay();
}

async function readAllFromDirectory(entry, collectedFiles, baseFolder = null) {
  return new Promise((resolve) => {
    const reader = entry.createReader();
    reader.readEntries(async (entries) => {
      for (const item of entries) {
        if (item.isFile) {
          await new Promise(res => item.file(file => {
            // Store top-level folder name from the first file path
            if (file.webkitRelativePath) {
  const folderName = file.webkitRelativePath.split("/")[0];
  const existing = folderStats.find(f => f.folderName === folderName);
  if (!existing) {
    folderStats.push({ folderName: folderName, count: 1 });
  } else {
    existing.count += 1;
  }
}
            collectedFiles.push(file);
            res();
          }));
        } else if (item.isDirectory) {
          await readAllFromDirectory(item, collectedFiles);
        }
      }
      resolve();
    });
  });
}

//CSV reader
readAllFromDirectory(entry, allFiles).then(() => {
  handleFolderDrop(allFiles);
});

//CSV importng names


//NUMBER FILTERING
const rangeLow = parseInt(document.getElementById("rangeLow").value, 10);
const rangeHigh = parseInt(document.getElementById("rangeHigh").value, 10);

function passesNumberRangeFilter(filename, min, max) {
  const match = filename.match(/\d{3}/); // looks for 3 consecutive digits
  if (!match) return false;

  const num = parseInt(match[0], 10);
  if (isNaN(num)) return false;

  if (min !== null && num < min) return false;
  if (max !== null && num > max) return false;

  return true;
}


//SUBMIT
function applyAllFilters() {
let inputPool = droppedFiles.slice(); // start with all files

folderResults = [];
currentPage = 0;
const folderBlocks = document.querySelectorAll(".folder-block");

folderBlocks.forEach((block, index) => {
  const rangeLow = parseInt(block.querySelector(".rangeLow").value, 10);
  const rangeHigh = parseInt(block.querySelector(".rangeHigh").value, 10);
  const tagInput = block.querySelector(".tagInput").value;
  const tagMode = block.querySelector(".tagMode").value;
  const customName = block.querySelector(".folderNameInput").value.trim();

  const oddOnly = block.querySelector(".filterOdd").checked;
  const evenOnly = block.querySelector(".filterEven").checked;
  const includeAlts = block.querySelector(".includeAlts").checked;
  const includeOn = block.querySelector(".includeOnFiles").checked;
  const includeXXX = block.querySelector(".includeXXX").checked;

  const tagList = tagInput
    .toUpperCase()
    .split(/[\s,]+/)
    .filter(tag => tag.length > 0 && /^[A-Z0-9]+$/.test(tag));

  const matched = inputPool.filter(file => {
const name = file.name.toUpperCase();

let importedList = [];

if (block.dataset.imported) {
  importedList = JSON.parse(block.dataset.imported);
 
  const useTag = block.querySelector(".useTagMatch").checked;

  const matchesCSV = importedList.some(entry => {
    const tagMatch = !useTag || (entry.tag && name.includes(entry.tag));
    const numMatch = name.includes(entry.num);
    return tagMatch && numMatch;
  });

  if (!matchesCSV) return false;
}

    // === Number matching ===
    const match = name.match(/\d{3}/);
    const isXXX = name.includes("XXX");

    if(isXXX) {
      if (!includeXXX) {
        return false;
      } else {
        return true;
      }
    }

      if (!match) return false;
      const num = parseInt(match[0], 10);
      if (!isNaN(rangeLow) && num < rangeLow) return false;
      if (!isNaN(rangeHigh) && num > rangeHigh) return false;

      if (oddOnly && !evenOnly && num % 2 !== 1) return false;
      if (evenOnly && !oddOnly && num % 2 !== 0) return false;


    // === Alt Art filter ===
    const digitIndex = match ? name.indexOf(match[0]) : -1;
    const afterChar = digitIndex >= 0 ? name.charAt(digitIndex + 3) : "-";
    if (!includeAlts && afterChar !== "-") return false;

    // === Overnumber filter ===
    if (!includeOn && name.includes("-ON-")) return false;

    // === Tag matching ===
    if (tagList.length > 0) {
      const tagMatchFn = (tag) => {
        const regex = new RegExp(`(^|[^A-Z0-9])${tag}([^A-Z0-9]|$)`);
        return regex.test(name);
      };

      if (tagMode === "and" && !tagList.every(tagMatchFn)) return false;
      if (tagMode === "or" && !tagList.some(tagMatchFn)) return false;
    }

    return true;
  });

  // Store results
  folderResults.push({
    folderNumber: index + 1,
    customName: customName || `ç­›é€‰æ–‡ä»¶å¤¹ ${index + 1}`,
    files: matched
  });

  // Update remaining pool
  inputPool = inputPool.filter(file => !matched.includes(file));
});

  folderResults.push({
    folderNumber: folderResults.length+1,
    customName: "æœªåŒ¹é…æ–‡ä»¶å¤¹",
    files: inputPool,
    isExcluded: true
  });
  console.log("Folder results: ", folderResults, "Imported List: ", importedNames);
  updateZipButtons(folderResults);
  currentPage = 0;
  renderResultTablePage();
}

//RESULTS TABLE
function nextResultPage() {
  if ((currentPage + 1) * foldersPerPage < folderResults.length) {
    currentPage++;
    renderResultTablePage();
  }
}

function prevResultPage() {
  if (currentPage > 0) {
    currentPage--;
    renderResultTablePage();
  }
}

function renderResultTablePage() {
  const container = document.getElementById("resultTableContainer");
  container.innerHTML = ""; // clear existing

  const startIndex = currentPage * foldersPerPage;
  const pageResults = folderResults.slice(startIndex, startIndex + foldersPerPage);

  const table = document.createElement("table");
  table.style.borderCollapse = "collapse";
  table.style.width = "100%";
  table.style.margin = "auto";
  table.border = "1";

  const headerRow = document.createElement("tr");
  pageResults.forEach(result => {
    const th = document.createElement("th");
    th.textContent = result.customName || `ç­›é€‰æ–‡ä»¶å¤¹ ${result.folderNumber}`;
    headerRow.appendChild(th);
  });
  table.appendChild(headerRow);

  // max rows = max number of files in either column
  const maxLength = Math.max(...pageResults.map(r => r.files.length));
  for (let i = 0; i < maxLength; i++) {
    const row = document.createElement("tr");
    pageResults.forEach(result => {
      const td = document.createElement("td");
      td.textContent = result.files[i]?.name || "";
      td.style.padding = "4px 8px";
      row.appendChild(td);
    });
    table.appendChild(row);
  }

  container.appendChild(table);

  // Button state
  document.getElementById("prevPageBtn").disabled = currentPage === 0;
  document.getElementById("nextPageBtn").disabled = (currentPage + 1) * foldersPerPage >= folderResults.length;
}



function tableControl() {
     const tableContainer = document.getElementById("resultTable");
    const button = document.getElementById("toggleTableBtn");

  const isVisible = tableContainer.style.display !== "none";

  if (isVisible) {
    // HIDE the table
    tableContainer.innerHTML = "";
    tableContainer.style.display = "none";
    button.textContent = "â¬‡ï¸ æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯";
    tableContainer.style.display = "none";
    isTableVisible = false;
  } else {
    // SHOW the table and build content
    let html = `
      <table border="1" cellpadding="8" style="border-collapse: collapse; width: 100%;">
        <thead>
          <tr>
            <th>âœ… ç¬¦åˆç­›é€‰</th>
            <th>ğŸš« æœªç¬¦åˆç­›é€‰</th>
          </tr>
        </thead>
        <tbody>
    `;

    const maxLength = Math.max(filteredFiles.length, excludedFiles.length);

    for (let i = 0; i < maxLength; i++) {
      html += "<tr>";
      html += `<td>${filteredFiles[i]?.name || ""}</td>`;
      html += `<td>${excludedFiles[i]?.name || ""}</td>`;
      html += "</tr>";
    }

    html += "</tbody></table>";

    tableContainer.innerHTML = html;
    tableContainer.style.display = "block";
    button.textContent = "â¬†ï¸ éšè—è¯¦ç»†ä¿¡æ¯";
    isTableVisible = true;
  }

 // console.log("Ref: " + tableContainer + ", Status: " + isVisible);
}


//Zipping the FOlders
function updateZipButtons(folderResults) {
  const container = document.getElementById("zipSection");
  container.innerHTML = ""; // Clear old content

  folderResults.forEach((result, index) => {
    const fileCount = result.files.length;
    const isExcluded = result.isExcluded;
    const label = result.customName;

    const block = document.createElement("div");
    block.style.textAlign = "center";
    block.style.width = "200px";

    if (fileCount > 0) {
      block.innerHTML = `
        <div style="font-size: 48px;">ğŸ“</div>
        <p>${label}<br>${fileCount} å¼ </p>
        <button onclick="downloadZip(folderResults[${index}].files, '${label}.zip')">ğŸ“¥ ä¸‹è½½</button>
      `;
    } else {
      block.innerHTML = `
        <div style="font-size: 48px; color: gray;">ğŸ“</div>
        <p>${label}<br>0 å¼ </p>
        <div style="color: gray;">âš ï¸ æ²¡æœ‰ç¬¦åˆçš„æ–‡ä»¶</div>
      `;
    }

    container.appendChild(block);
  });
}

//Changing the UI for AND OR
function tagModeText(selectElement) {
  const folderBlock = selectElement.closest(".folder-block");
  const helper = folderBlock.querySelector(".tagHelperText");

  if (selectElement.value === "and") {
    helper.textContent = "å¿…é¡»åŒ…å«è¾“å…¥çš„æ‰€æœ‰æ ‡ç­¾";
  } else {
    helper.textContent = "ä»»æ„æ ‡ç­¾ç¬¦åˆå³å¯é€šè¿‡ç­›é€‰";
  }
}

//NEWWWW BLOCKKK
function NewFolder() {
  folderCount++;
  //console.log("new folder", container, addbBtn);
  const container = document.getElementById("folderFilterContainer");
  const addbBtn = document.getElementById("addFolderBtn");

  const block = document.createElement("div");

  block.classList.add("folder-block");
  block.setAttribute("data-folder-id", folderCount);
  block.style.marginBottom = "20px";
  block.style.padding = "12px";
  block.style.border = "1px solid #ccc";
  block.style.borderRadius = "8px";
  block.style.backgroundColor = "white";

  block.innerHTML = `
    <h2>ğŸ“ ç­›é€‰æ–‡ä»¶å¤¹ ${folderCount}</h2>
    <label>
      æ–‡ä»¶å¤¹åç§°ï¼š
      <input type="text" class="folderNameInput" placeholder="ä¾‹å¦‚ï¼šç¼–å·å¡ç»„ã€æ— æ ‡ç­¾å¡ç»„" style="width: 90%; margin-top: 6px; margin-bottom: 12px;" />
    </label>
    <div class="row">
      <label>
        ç¼–å·èŒƒå›´ï¼ˆä¾‹å¦‚ï¼š5-10ï¼‰ï¼š
        <input type="number" class="rangeLow" placeholder="æœ€å°" min="0" max="999" />
        â€”
        <input type="number" class="rangeHigh" placeholder="æœ€å¤§" min="0" max="999" />
      </label>
    </div>

    <div style="margin-bottom: 15px;">
      <label for="tagMode">æ ‡ç­¾åŒ¹é…æ¨¡å¼ï¼š</label>
    <select class="tagMode" onchange="tagModeText(this)">
      <option value="or" selected>ä»»æ„æ ‡ç­¾ï¼ˆORï¼‰</option>
      <option value="and">å…¨éƒ¨æ ‡ç­¾ï¼ˆANDï¼‰</option>
  </select>
  <input
    type="text"
    class="tagInput"
    placeholder="è¯·è¾“å…¥æ ‡ç­¾ï¼Œä¾‹å¦‚ï¼šOGN, Annie, R"
    style="margin-top: 8px; width: 300px;"
  />
  <div class="tagHelperText" style="color: gray; font-size: 13px; margin-top: 4px;">
    ä»»æ„æ ‡ç­¾ç¬¦åˆå³å¯é€šè¿‡ç­›é€‰
  </div>

  <div style="margin-top: 20px;">
  <label>
  ğŸ“ å¯¼å…¥ Airtable CSVï¼š
  <input type="file" class="csvInput" accept=".csv" />
</label>
<label style="font-size: small; margin-top: 0%;">
  <input type="checkbox" class="useTagMatch" unchecked />
  åŒæ—¶åŒ¹é…æ ‡ç­¾ï¼ˆTAGï¼‰å’Œç¼–å·ï¼ˆNUMï¼‰
</label>
</div>

  </div>
    <div class="row">
      <label><input type="checkbox" class="filterOdd" /> åªåŒ…å«å¥‡æ•°</label>
      <label><input type="checkbox" class="filterEven" /> åªåŒ…å«å¶æ•°</label>
      <label><input type="checkbox" class="includeAlts" unchecked /> åŒ…å«Alt</label>
      <label><input type="checkbox" class="includeOnFiles" unchecked /> åŒ…å«OVERNUMBER</label>
      <label><input type="checkbox" class="includeXXX" checked /> åŒ…å«æ²¡æœ‰ç¼–å·ï¼ˆXXXï¼‰</label>
    </div>
    <button class="removeFolderBtn" style="float: right; font-size: 12px; background-color: #ffdddd; border: 1px solid #cc0000; border-radius: 4px; cursor: pointer; margin-bottom: 10px;">
  âŒ åˆ é™¤æ­¤æ–‡ä»¶å¤¹
</button>
  `;

  const csvInput = block.querySelector(".csvInput");
const useTagCheckbox = block.querySelector(".useTagMatch");

csvInput.addEventListener("change", (e) => {
  const file = e.target.files[0];
  if (!file) return;

  parseCSVAndStore(block, file, useTagCheckbox);
});

  // Append to container
  container.appendChild(block);
  container.appendChild(addbBtn);
  addbBtn.style.display = "inline-block";

  block.querySelector(".removeFolderBtn").addEventListener("click", () => {
  const allFolders = document.querySelectorAll(".folder-block");

  // Prevent deleting the last one
  if (allFolders.length === 1) {
    alert("è‡³å°‘éœ€è¦ä¿ç•™ä¸€ä¸ªç­›é€‰æ–‡ä»¶å¤¹ï¼");
    return;
  }

  block.remove(); // remove this block
  reindexFolders(); // re-label folder numbers if needed
});
}

function reindexFolders() {
  const blocks = document.querySelectorAll(".folder-block");
  blocks.forEach((block, index) => {
    block.setAttribute("data-folder-id", index + 1);

    // Optional: auto-update default folder name input
    const nameInput = block.querySelector(".folderNameInput");
    if (nameInput && nameInput.value.startsWith("ç­›é€‰æ–‡ä»¶å¤¹")) {
      nameInput.value = `ç­›é€‰æ–‡ä»¶å¤¹ ${index + 1}`;
    }

    // Optional: update <h2> header if you're using those
    const heading = block.querySelector("h2, h3");
    if (heading && heading.textContent.includes("ç­›é€‰æ–‡ä»¶å¤¹")) {
      heading.textContent = `ğŸ“ ç­›é€‰æ–‡ä»¶å¤¹ ${index + 1}`;
    }
  });

  // Reset folderCount to match current count
  folderCount = blocks.length;
}

function parseCSVAndStore(block, file, useTagCheckbox) {
  const reader = new FileReader();

  reader.onload = function (event) {
    const text = event.target.result;
    const lines = text.split("\n");

    const parsedConditions = [];

    lines.forEach(line => {
      const raw = line.split(",")[0].trim().toUpperCase();

      if (!raw.endsWith("_CARDNAME")) return;

      const beforeCardname = raw.split("_CARDNAME")[0];
      const parts = beforeCardname.split(/[-_/]/);

      const num = parts[parts.length - 2]?.padStart(3, "0");
      const tag = parts[parts.length - 3];

      if (tag && num && /^\d{3}$/.test(num)) {
        parsedConditions.push({ tag, num });
      }
    });

    block.dataset.imported = JSON.stringify(parsedConditions);
    block.dataset.useTagMatch = useTagCheckbox?.checked ? "true" : "false";

    alert(`âœ… æˆåŠŸå¯¼å…¥ ${parsedConditions.length} æ¡ç­›é€‰æ¡ä»¶`);
    console.log("ğŸ“‚ å¯¼å…¥æ¡ä»¶ï¼š", parsedConditions);
  };

  reader.readAsText(file);
}

  </script>

</body>
</html>
